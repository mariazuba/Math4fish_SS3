---
title: "Descripción de los archivos de datos"
---

&nbsp;
&nbsp;

# Archivos requeridos


```{css,echo=FALSE}
.scroll-200{
            max-height: 200px; 
            overflow-y: auto; 
            background-color: #f1f1f1;
            }
```



```{css,echo=FALSE}

/*----------LOGO above TOC---------*/

#TOC::before {
  content: "";
  display: block;
  height: 100px;
  margin: 2em 20px 40px 20px;
  background-image: url("LOGO_2SN_recortado.png");
  background-size: contain;
  background-position: center center;
  background-repeat: no-repeat;
}

```



```{r echo=F, message=F,warning=F,}

library(reshape2)
require(dplyr)
require(tidyr)
library(knitr) #Rmarkdown
library(ggplot2) # plot
library(patchwork) # plot
library(kableExtra) # genera tablas
library(r4ss)

#remotes::install_github("PIFSCstockassessments/ss3diags")

mod_path<-(paste(getwd(),'/model_files/simple',sep=""))

knitr::opts_chunk$set(echo=T, warning=F, message=F)

```



Los archivos de datos necesarios para que SS3 funcione son los siguientes:

1.  **starter.ss**: archivo requerido que contiene los nombres de los archivos de datos y control, además de otros controles de ejecución.
2.  **data.ss**: archivo que contiene las dimensiones del modelo y los  datos
3.  **control.ss**: archivo que contiene la configuración de los parámetros
4.  **forecast.ss**: archivo que contiene especificaciones para puntos de referencia y proyecciones

Cuando el programa se inicia por primera vez, lee el archivo starter.ss, que normalmente debe estar ubicado en el mismo directorio desde el que se ejecuta SS3 (**ss.exe**). 

Los archivos de datos se pueden leer como objetos de lista en R usando las funciones SS_read*(). Los componentes de la lista deben estar en el mismo orden en que aparecen en el archivo de texto. Puede usar la función names() para ver todos los componentes de la lista.

&nbsp;
&nbsp;

## Starter

SS3 comienza leyendo el archivo starter.ss, el cual contiene los nombres de los archivos de datos y control, además de otros controles de ejecución. Los nombres de los archivos de control.ss y data.ss deben coincidir con los nombres especificados en el archivo starter.ss. En esta sección se especifican los ajustes a los parámetros iniciales, summary y convergencia del modelo. [Consulte la Guía de usuario de SS3](intro.html), Sección 5 "Starter File Syntax".


Podemos ver el contenido del archivo  usando la función "SS_readstarter" de r4ss. En este link puedes [Descargar archivo starter](https://mariazuba.github.io/Math4fish_SS3/model_files/simple/starter.ss) y guardarlo en tu directorio de trabajo.


```{r echo=T, message=F,warning=F}

start <- r4ss::SS_readstarter(file = file.path(mod_path, "starter.ss"),
                              verbose = FALSE)


kbl(t(data.frame(start))[,1], booktabs = T,position="h!",
caption = "Contenido de archivo starter") %>% 
  kable_styling("striped",
                full_width = FALSE,font_size=12 )%>% 
  scroll_box(width="100%",height="500px")
```

&nbsp; &nbsp;

## Data 

A continuación se describe como ingresar las especificaciones del modelo, definición de flotas/campañas y los datos de capturas, índices, descarte, composiciones de tallas y edades, entre otros.

Podemos leer el archivo  usando la función "SS_readdat" de r4ss y ver los componentes de la lista con la función names(). En este link puedes [Descargar archivo data](https://mariazuba.github.io/Math4fish_SS3/model_files/simple/data.ss) y guardarlo en tu directorio de trabajo.


```{r message=F,warning=F,class.output="scroll-200"}

# lee archivo data.ss

dat <- r4ss::SS_readdat(file = file.path(mod_path, start$datfile),
                        verbose = FALSE)

# Genera Tabla de los componentes del objeto "dat". 

kbl(data.frame(names_data=names(dat)), booktabs = T,position="h!") %>% 
  kable_styling("striped",full_width=F,font_size=12)%>% 
  scroll_box(width="100%",height="500px")

```

&nbsp;
&nbsp;

### Dimensiones

En esta sección se especifican el número de años, meses/temporadas de las observaciones, número de edades, sexos, áreas, número de flotas y campañas, entre otras.[Consulte la Guía de usuario de SS3: Sección 7.5 "Model Dimensions"](https://nmfs-stock-synthesis.github.io/doc/SS330_User_Manual.html#model-dimensions).

```{r echo=F, message=F,warning=F}
esp<-data.frame(dat$styr,dat$endyr,dat$nseas,dat$months_per_seas[1],
                dat$Nsubseasons,dat$spawn_month,dat$Ngenders,dat$Nsexes,
                dat$Nages,dat$N_areas,dat$Nfleets)

# Genera Tabla

kbl(t(esp), booktabs = T,position="h!",
caption = "Especificaciones de los datos") %>% 
  kable_styling("striped",full_width=F,font_size=12)

```

&nbsp;
&nbsp;

### Definición de flotas y campañas

En esta sección se especifica el tipo de flota, mes/temporada de la observación, areas donde opero la flota/campaña, unidades de medida de la observación y una opción para utilizar un multiplicador de la captura. **fleet_type:** 1=catch fleet; 2=bycatch only fleet;3=survey; 4=predator(M2). **sample_timing:** -1 for fishing fleet to use season-long catch-at-age for observations, or 1 to use observation month; (always 1 for surveys). **fleet_area:** area the fleet/survey operates in. **units of catch:** 1=bio; 2=num (ignored for surveys; their units read later). **catch_mult:** 0=no; 1=yes. **rows are fleets**.

```{r echo=F,message=F,warning=F}

kbl(dat$fleetinfo, booktabs = T,position="h!",
caption = "Definición de flotas y campañas") %>% 
  kable_styling("striped",full_width=F,font_size=12)

```

&nbsp;
&nbsp;

### Captura comercial

Los datos de capturas ingresan por año, temporada de pesca, tipo de flota, valor observado de la captura y coeficiente de variación. **Catch data**: yr, seas, fleet, catch, catch_se. **catch_se**: standard error of log(catch). **NOTE**: catch data is ignored for survey fleets

```{r echo=F,message=F,warning=F}
catch<-dat$catch 

kbl(catch, booktabs = T,position="h!",
caption = "Datos de captura comercial") %>% 
  kable_styling("striped",full_width=F,font_size=12)%>% 
  scroll_box(width="100%",height="500px")


```

&nbsp;
&nbsp;

### Índices de abundancia {.tabset .tabset-fade }

En las primeras líneas se describen algunas especificaciones de los índices, como las unidades de medida y distribución del error, para posteriormente ingresar los datos por año, mes, flota y coeficiente de variación. **Units**: 0=numbers; 1=biomass; 2=F; 30=spawnbio; 31=recdev; 32=spawnbio\*recdev; 33=recruitment; 34=depletion(&see Qsetup); 35=parm_dev(&see Qsetup). **Errtype**: -1=normal; 0=lognormal; \>0=T. **SD_Report**: 0=no sdreport; 1=enable sdreport.

#### Especificaciones
```{r echo=F,message=F,warning=F}

CPUEinfo<-dat$CPUEinfo #contiene las especificaciones de las campañas

kbl(CPUEinfo, booktabs = T,position="h!",
caption = "Especificaciones de los índices") %>% 
  kable_styling("striped",
                full_width = FALSE,font_size=12)
```

#### Datos
```{r echo=F, message=F,warning=F}

CPUE<-dat$CPUE # contiene los datos de campañas

kbl(CPUE, booktabs = T,position="h!",
caption = "Datos de campañas") %>% 
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%",height="500px")

```

&nbsp;
&nbsp;

#### Composiciones de tallas {.tabset .tabset-fade }

En esta sección se ingresan los datos de composiciones de tallas por año, mes, tipo de flota, sexo y tamaño de muestra, especificando previamente el método de agrupamiento (bins) de las tallas, distribución de la estructura de error, entre otras especificaciones.

##### Flota

```{r echo=F, message=F,warning=F}
tallas_a<-dat$lencomp  %>% filter(FltSvy==1)
tallas_a<-tallas_a


kbl(tallas_a, booktabs = T,position="h!",digits = 0,
caption = "Datos de composición de tallas de la Flota") %>% 
  kable_styling("striped",
                full_width = FALSE,font_size=12) %>% 
  scroll_box(width="100%",height="500px")


```

##### PELAGO

```{r echo=F, message=F,warning=F}
tallas2<-dat$lencomp  %>% filter(FltSvy==2)

kbl(tallas2, booktabs = T,position="h!",digits = 0,
caption = "Datos de composición de tallas de PELAGO") %>% 
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%",height="500px")


```

##### ECOCADIZ

```{r echo=F, message=F,warning=F}
tallas3<-dat$lencomp  %>% filter(FltSvy==3)

kbl(tallas3, booktabs = T,position="h!",digits = 0,
caption = "Datos de composición de tallas de ECOCADIZ") %>% 
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%",height="500px")


```


&nbsp;

&nbsp;

## Control

La función principal del archivo de control es definir los parámetros que utilizará el modelo.  Cada línea de parámetro contiene: un valor mínimo (LO), máximo (HI), inicial (INIT), valor esperado (PRIOR), coeficiente de variación del valor esperado (PRIOR SD), tipo de distribución de error del valor esperado (PRIOR TYPE), fase de estimación (PHASE). Se pueden aplicar tres tipos de propiedades variables en el tiempo a un parámetro base: vinculación ambiental (Env var & Link), desviación aleatoria (Dev link, Dev min yr, Dev max yr, Dev phase) y bloques o tendencia (Block y Block function). 

[Descarga archivo control](https://mariazuba.github.io/Math4fish_SS3/model_files/simple/control.ss)

```{r echo=F,message=F,warning=F,class.output="scroll-200"}

# Read in ctl file. Note that the data fileR object is needed so that SS_readctl
# assumes the correct data structure
ctl <- r4ss::SS_readctl(file = file.path(mod_path, start$ctlfile),
                        verbose = FALSE, use_datlist = TRUE, datlist = dat)

#names(ctl) # see names of the list components of ctl

```

&nbsp;
&nbsp;

### Parámetros biológicos {.tabset .tabset-fade }

#### Especificaciones 

1. *Tipos de mortalidad natural*: 0 = 1Parm; 1 = N_breakpoints; 2 = Lorenzen; 3 = agespecific; 4 = agespec with seas interpolate no additional input for selected M option; read 1P per morph
  
2. *Modelo de crecimiento*:  1 = vonBert with L1&L2; 2 = Richards with L1&L2; 3 = age_specific_K; 4 = not implemented

3. *CV del patrón de crecimiento*: 0 CV=f(LAA); 1 CV=F(A); 2 SD=F(LAA); 3 SD=F(A); 4 logSD=F(A)

4. *Opción de madurez*: 1 = length logistic; 2 = age logistic;  3 = read age-maturity matrix by growth_pattern;  4 = read age-fecundity;  5 = disabled;  6 = read length-maturity

5. *Opción de fecundidad*: (1) eggs=Wt*(a+b*Wt); (2) eggs=a*L^b; (3) eggs=a*Wt^b;  (4) eggs=a+b*L;  (5) eggs=a+b*W

6. *Opción de hermaphroditismo*:  0 = none;  1 = female-to-male age-specific fxn;  -1 = male-to-female age-specific fxn

&nbsp;
&nbsp;

#### Parámetros

```{r echo=F, message=F,warning=F}

parbio<-ctl$MG_parms

kbl(parbio, booktabs = T,position="h!",
caption = "Parámetros biológicos") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%")


```

&nbsp;
&nbsp;

### Reclutamiento {.tabset .tabset-fade }

&nbsp;
&nbsp;

#### Especificaciones


1. *SR_function*: 2 = Ricker; 3 = std_B-H; 4 = SCAA; 5 = Hockey; 6 = B-H_flattop; 7 = survival_3Parm; 8 = Shepard_3Parm

2. *do_recdev*: 0 = none;  1 = devvector;  2 = simple deviations

&nbsp;
&nbsp;

#### Parámetros

```{r echo=F, message=F,warning=F}

parrecl<-ctl$SR_parms

kbl(parrecl, booktabs = T,position="h!",
caption = "Reclutamiento") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%")


```

&nbsp;
&nbsp;

### Capturabilidad {.tabset .tabset-fade }

#### Especificaciones

```{r echo=F, message=F,warning=F}

parQ_option<-ctl$Q_options

kbl(parQ_option, booktabs = T,position="h!") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)

```

#### Datos 

```{r echo=F, message=F,warning=F}

parQ_par<-ctl$Q_parms

kbl(parQ_par, booktabs = T,position="h!") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%")


```

&nbsp;
&nbsp;

### Selectividad

&nbsp;
&nbsp;

#### Selectividad a la talla {.tabset .tabset-fade }

##### Especificaciones

```{r echo=F, message=F,warning=F}

parsel_type<-ctl$size_selex_types

kbl(parsel_type, booktabs = T,position="h!",
caption = "Especificación de la selectividad a la talla") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)

```

##### Parámetros

```{r echo=F, message=F,warning=F}

parsel_par<-ctl$size_selex_parms

kbl(parsel_par, booktabs = T,position="h!",
caption = "Parámetros de selectividad a la talla") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%")


```

&nbsp;
&nbsp;

#### Selectividad a la edad {.tabset .tabset-fade }

##### Especificaciones

```{r echo=F, message=F,warning=F}

parsel_type<-ctl$age_selex_types

kbl(parsel_type, booktabs = T,position="h!",
caption = "Especificación de la selectividad a la edad") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)

```

##### Parámetros

```{r echo=F, message=F,warning=F}

parsel_par<-ctl$age_selex_parms

kbl(parsel_par, booktabs = T,position="h!",
caption = "Parámetros de selectividad a la edad") %>%
  kable_styling("striped",
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%")


```

&nbsp;
&nbsp;

## Forecast

En este archivo se pueden especificar los puntos biológicos de referencia, los años de proyección y reglas de control, entre otras especificaciones.

A continuación se muestra el archivo crudo que puedes encontrar al [Descarga archivo forecast](https://mariazuba.github.io/Math4fish_SS3/model_files/simple/forecast.ss). Cada línea corresponde a una especificación comentada con simbolo #.



```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE, eval=F}
#V3.30.19.00;_safe;_compile_date:_Apr  4 2022;_Stock_Synthesis_by_Richard_Methot_(NOAA)_using_ADMB_12.3
#C generic forecast file
# for all year entries except rebuilder; enter either: actual year, -999 for styr, 0 for endyr, neg number for rel. endyr
1 # Benchmarks: 0=skip; 1=calc F_spr,F_btgt,F_msy; 2=calc F_spr,F0.1,F_msy; 3=add F_Blimit; 
2 # Do_MSY: 1= set to F(SPR); 2=calc F(MSY); 3=set to F(Btgt) or F0.1; 4=set to F(endyr); 5=calc F(MEY) with MSY_unit options
# if Do_MSY=5, enter MSY_Units; then list fleet_ID, cost/F, price/mt, include_in_Fmey_scaling; # -fleet_ID to fill; -9999 to terminate
0.4 # SPR target (e.g. 0.40)
0.342 # Biomass target (e.g. 0.40)
#_Bmark_years: beg_bio, end_bio, beg_selex, end_selex, beg_relF, end_relF, beg_recr_dist, end_recr_dist, beg_SRparm, end_SRparm (enter actual year, or values of 0 or -integer to be rel. endyr)
 2001 2001 2001 2001 2001 2001 1971 2001 1971 2001
#  2001 2001 2001 2001 2001 2001 1971 2001 1971 2001
# value <0 convert to endyr-value; except -999 converts to start_yr; must be >=start_yr and <=endyr
1 #Bmark_relF_Basis: 1 = use year range; 2 = set relF same as forecast below
#
1 # Forecast: -1=none; 0=simple_1yr; 1=F(SPR); 2=F(MSY) 3=F(Btgt) or F0.1; 4=Ave F (uses first-last relF yrs); 5=input annual F scalar
# where none and simple require no input after this line; simple sets forecast F same as end year F
10 # N forecast years 
0.2 # Fmult (only used for Do_Forecast==5) such that apical_F(f)=Fmult*relF(f)
#_Fcast_years:  beg_selex, end_selex, beg_relF, end_relF, beg_mean recruits, end_recruits  (enter actual year, or values of 0 or -integer to be rel. endyr)
 0 0 -10 0 -999 0
#  2001 2001 1991 2001 1971 2001
0 # Forecast selectivity (0=fcast selex is mean from year range; 1=fcast selectivity from annual time-vary parms)
1 # Control rule method (0: none; 1: ramp does catch=f(SSB), buffer on F; 2: ramp does F=f(SSB), buffer on F; 3: ramp does catch=f(SSB), buffer on catch; 4: ramp does F=f(SSB), buffer on catch) 
# values for top, bottom and buffer exist, but not used when Policy=0
0.4 # Control rule Biomass level for constant F (as frac of Bzero, e.g. 0.40); (Must be > the no F level below) 
0.1 # Control rule Biomass level for no F (as frac of Bzero, e.g. 0.10) 
0.75 # Buffer:  enter Control rule target as fraction of Flimit (e.g. 0.75), negative value invokes list of [year, scalar] with filling from year to YrMax 
3 #_N forecast loops (1=OFL only; 2=ABC; 3=get F from forecast ABC catch with allocations applied)
3 #_First forecast loop with stochastic recruitment
1 #_Forecast recruitment:  0= spawn_recr; 1=value*spawn_recr_fxn; 2=value*VirginRecr; 3=recent mean from yr range above (need to set phase to -1 in control to get constant recruitment in MCMC)
1 # value is multiplier of SRR 
0 #_Forecast loop control #5 (reserved for future bells&whistles) 
2010  #FirstYear for caps and allocations (should be after years with fixed inputs) 
0 # stddev of log(realized catch/target catch) in forecast (set value>0.0 to cause active impl_error)
0 # Do West Coast gfish rebuilder output: 0=no; 1=yes 
1999 # Rebuilder:  first year catch could have been set to zero (Ydecl)(-1 to set to 1999)
2002 # Rebuilder:  year for current age structure (Yinit) (-1 to set to endyear+1)
1 # fleet relative F:  1=use first-last alloc year; 2=read seas, fleet, alloc list below
# Note that fleet allocation is used directly as average F if Do_Forecast=4 
2 # basis for fcast catch tuning and for fcast catch caps and allocation  (2=deadbio; 3=retainbio; 5=deadnum; 6=retainnum); NOTE: same units for all fleets
# Conditional input if relative F choice = 2
# enter list of:  season,  fleet, relF; if used, terminate with season=-9999
# 1 1 1
# -9999 0 0  # terminator for list of relF
# enter list of: fleet number, max annual catch for fleets with a max; terminate with fleet=-9999
-9999 -1
# enter list of area ID and max annual catch; terminate with area=-9999
-9999 -1
# enter list of fleet number and allocation group assignment, if any; terminate with fleet=-9999
-9999 -1
#_if N allocation groups >0, list year, allocation fraction for each group 
# list sequentially because read values fill to end of N forecast
# terminate with -9999 in year field 
# no allocation groups
#
2 # basis for input Fcast catch: -1=read basis with each obs; 2=dead catch; 3=retained catch; 99=input apical_F; NOTE: bio vs num based on fleet's catchunits
#enter list of Fcast catches or Fa; terminate with line having year=-9999
#_Yr Seas Fleet Catch(or_F)
-9999 1 1 0 
#
999 # verify end of input 
```


Para revisar las líneas que se están leyendo de nuestro código podemos utilizar la función SS_readforecast de la librería r4ss y de esta forma visualizar los datos que nos interesan.

```{r echo=T, message=F,warning=F}

# Lee el archivo forecast

fore <- r4ss::SS_readforecast(file = file.path(mod_path, "forecast.ss"),
                              verbose = FALSE)
# can also read in wtatage.ss for an empirical wt at age model using
# r4ss::SS_readwtatage()
#names(fore) # see names of the list components of forecast

# Selecciono los datos que puedo ver el lista
fore_kbl<-data.frame(fore[2:8],fore[10:13],fore[15:33])

# Genera la tabla 
kbl(t(fore_kbl), booktabs = T, position="h!")%>%
  kable_styling(latex_options = c("striped"),
                full_width = FALSE,font_size=12)%>% 
  scroll_box(width="100%",height="500px")

```
